<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Workflow for NWOS Tables</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>




</head>

<body>
<h1>Workflow for NWOS Tables</h1>

<h2>The Raw Data Inputs</h2>

<h3>&ldquo;POINTS_XXX&rdquo;</h3>

<ul>
<li><p>These are data on the individual FIA plots (points). They are pulled separately for each region from the NIMS database and are in a zip folder, under &ldquo;InputData/ZipFiles/Current/Points.rar&rdquo;. They need to be extracted to InputData/Delete/.</p></li>
<li><p>The naming protocol is &ldquo;POINTS_XXX.csv&rdquo;, where XXX is the region abbrevation.</p></li>
<li><p>We&#39;ve so far used data that is summarized by count, but we have switched to a per-plot basis.</p></li>
<li><p>The SQL code to generate this table is stored in &ldquo;/InputData/Documentation /SQL_POINTS_XXX.sql&rdquo;</p></li>
<li><p>FIA&#39;s documentation on the field names of the POINTS_XXX.csv files can be found in &ldquo;InputData/Documentation/FIA_Manual_5-1-2.pdf&rdquo;, but the important ones are:</p>

<ul>
<li>STATECD - the state FIPS code</li>
<li>COUNTYCD - the county FIPS code, only critical for TX and OK (dividing into East and West)</li>
<li>INVYR - FIA inventory year, used to match to the corresponding NWOS year</li>
<li>COND_STATUS_CD - land cover code</li>
<li>forest land</li>
<li>non-sampled</li>
<li>COND_NONSAMPLE_REASN_CD - reason for not sampling</li>
<li>denied access (most likely private)</li>
<li>hazardous</li>
<li>OWNCD - the ownership type code
41-44. private, non-family</li>
<li>family</li>
</ul></li>
<li><p>The function, readPoints() brings in these files internally to the makePointsQuest() function.</p></li>
</ul>

<h3>&ldquo;Nonsampled&rdquo;</h3>

<ul>
<li><p>FIA plots that were not sampled by FIA - the reason for not sampling it and a descriptions of the stratum to which it belongs.</p></li>
<li><p>The stratum description scheme (&ldquo;STRATUM_DESCR&rdquo;) differs by region, but the goal is to &ldquo;guess&rdquo; which non-sampled points were private forest. That enables us to calculate a FIA response rate, the inverse of which we use to weight estimates. See the function makeNs() for exact details.</p></li>
<li><p>For an exploration of the different STRATUM_DESCR&#39;s by region, open up the project, &ldquo;nonsampling.Rproj&rdquo;.</p></li>
</ul>

<h3>&ldquo;LandArea&rdquo;</h3>

<ul>
<li><p>Total area of land by stratum (state, except for Texas and Oklahoma).</p></li>
<li><p>Ideally, we will change the data format to by-county for the sake of consistency. Then it can be aggregated into by-strata.</p></li>
<li><p>For now it is in the files &ldquo;/InputData/LandArea.csv&rdquo;, &ldquo;/InputData/LandAreaOK&rdquo; and &ldquo;InputData/LandAreaTX&rdquo;.</p></li>
<li><p>The area data come from the Census Bureau, but there is no documentation for this at the moment.</p></li>
</ul>

<h3>&ldquo;YearMatch&rdquo;</h3>

<ul>
<li><p>Shows the FIA INVYR associated with each NWOSYEAR for each state. This is needed to pull out the right stratum info from POINTS_XXX for the corresponding NWOS cycle.</p></li>
<li><p>Right now it&#39;s in two different files: &ldquo;/InputData/YearMatch2006.csv&rdquo; and &ldquo;/InputData/YearMatch2011.csv&rdquo;.</p></li>
</ul>

<h3>&ldquo;QUEST&rdquo;</h3>

<ul>
<li><p>The NWOS questionnaire data.</p></li>
<li><p>The 2006 data are in an Access database under InputData/Access/NWOS_DB_2006.accdb. The table QUEST needs to be exported to InputData/Delete/ and called &ldquo;Quest2006.csv&rdquo;</p></li>
<li><p>Part of the 2011 data are in an Access Database under &ldquo;InputData/Access/NWOS_2011.accdb&rdquo;. The table QUEST1 has only the first dozen or so fields from the full questionnaire data.frame. In Access, there is an update query that [already done] tacks on a &ldquo;county&rdquo; field so that TX and OK can be divided into East and West. QUEST1 needs to be exported to &ldquo;InputData/Delete/Quest2011a&rdquo;. For unknown reasons, the rest of the data.frame is in a zip folder under &ldquo;InputData/ZipFiles/Quest2011.rar&rdquo;, called &ldquo;X_NWOS_2011&hellip; .csv&rdquo; and should be extracted to &ldquo;InputData/Delete/Quest2011b.csv&rdquo;</p></li>
<li><p>This system is VERY problematic and will likely be replaced in the future.</p></li>
</ul>

<h2>Bringing in the Raw Data</h2>

<p>Right now, these files are brought in with a messy function called makePointsQuest(). This needs desperately to be cleaned up, but it can be viewed on my Github site at <a href="https://github.com/Brent-Dickinson/estimation-package">https://github.com/Brent-Dickinson/estimation-package</a> under /data setup/. If you have the library on your system, just give the argument datawd = &ldquo;/your directory/&rdquo; to makePointsQuest():</p>

<pre><code class="r">source(&quot;data setup/makePointsQuest.R&quot;)
makePointsQuest(datawd = &quot;e:/brent/nwos/inputdata/&quot;)
</code></pre>

<h2>Consolidating stratum info</h2>

<p>Once these files are loaded, the first step is to use them to create a simplified data.frame that contains all necessary information about each stratum. The function, makeNs() does this automatically - you just have to specify the names you&#39;ve given to the 5 input files. Of course, until the package actually becomes a package, you&#39;ll need to manually source all the necessary functions:</p>

<pre><code class="r">functions = list(&quot;makeQuestAll&quot;, &quot;makeNs&quot;, &quot;stateTables&quot;, &quot;regionTables&quot;, &quot;hheCore&quot;, 
    &quot;cov1&quot;, &quot;varianceRatio&quot;, &quot;varDifferenceRatios&quot;, &quot;stateTableContinuous&quot;)
functions = sapply(functions, function(x) paste(&quot;functions/&quot;, x, &quot;.R&quot;, sep = &quot;&quot;))
for (i in 1:length(functions)) {
    source(functions[i])
    rm(i)
}
</code></pre>

<p>Now do the makeNs() thing:</p>

<pre><code class="r">ns_11 = makeNs(quest = quest_11, points = points_11, nonsampled = nonsampled_11)
ns_N11 = makeNs(quest = quest_11, points = points_11, nonsampled = nonsampled_N11)
ns_N11 = ns_N11[ns_N11$rpa_regionCd == 1, ]
ns_06 = makeNs(quest = quest_06, points = points_06, nonsampled = nonsampled_06)
</code></pre>

<pre><code>## Error: undefined columns selected
</code></pre>

<pre><code class="r">ns_N06 = makeNs(quest = quest_06, points = points_06, nonsampled = nonsampled_N06, 
    nwosCycle = 2006)
ns_N06 = ns_N06[ns_N06$rpa_regionCd == 1, ]
</code></pre>

<h2>Estimate response probabilities for inverse weighting</h2>

<p>The next step is to decide on a way to estimate the NWOS response probabilies for all responding ownerships. At present we only have code to use the &ldquo;naive&rdquo; method, which is in the file construct response rates.R. Source this:</p>

<pre><code class="r">source(&quot;data setup/construct response rates.R&quot;)
</code></pre>

<h2>Tweak QUEST to get desired variables into an estimation-friendly format</h2>

<p>Next we refine the QUEST file (remove acreage non-respondents) and augment it with variables of interest created from the raw variables. The function, makeQuestAll(), does this. The raw QUEST Variables for the most part cannot be used as is because of issues like -2&#39;s, 8&#39;s, 9&#39;s, and idiosyncratic differences between 2006 and later variable coding protocols.</p>

<pre><code class="r">questAll_11 = makeQuestAll(quest = quest_11, nwosCycle = 2011)
</code></pre>

<p>Using makeNs() and makeQuestAll(), we&#39;ve assembled the two components needed for any kind of estimation. Now we move on to whatever it is that we want to do with the data. The most basic task weill be to create the NWOS tables from GTR-NRS-27.</p>

<h2>Making the NWOS tables</h2>

<p>Whether state, regional, or national level estimates are desired, we start with the function stateTables() for categorical variables, and stateTableContinuous() for continuous variables. </p>

<p>Nearly all NWOS estimators (except regression, etc) are built on the Hansen-Hurwitz estimator of total, which is what hheCore() does. Most variance estimators require covariance terms, which cov1() takes care of. stateTables() and stateTableContinuous() are built on these. Both functions require the following inputs:</p>

<ol>
<li>A vector of column indexes from questAllXX that indicate the variables for which you want estimates.</li>
<li>The questAllXX data.frame.</li>
<li>The stratumInfo data.frame (constructed using makeNs).</li>
<li>A factor with length == nrow(questAllXX), with level &ldquo;population&rdquo; for observations in the population of interest. For family forest ownerships, this is augmented to the questAllXX data.frame itself. For all private forest ownerships, simply use factor(rep(&ldquo;population&rdquo;, nrow(questAllXX)))</li>
<li>The NWOS cycle (2006 or 2011) (This is redundant and will be changed later).</li>
</ol>

<h3>A note on why different functions are used for categorical and continuous variables:</h3>

<ul>
<li><p>For categorical variables, what we really want is number of acres and ownerships in each category of the variable. What stateTables() does is apply hheCore() separately to acres owned and to a vector of 1&#39;s to get those respective estimates. The ratio of acres and ownerhsips is the mean. stateTables() also estimates the number of acres and ownerships in the population of interest, for purposes of estimating proportions of ownerships and acres in each category of the variable. </p></li>
<li><p>For continuous variables, what we want is the total for that variable. So stateTableContinuous() applies hheCore() to the continuous variable. stateTableContinuous() also estimates the total number of ownerships in the population of interest for purposes of estimating the mean value of the continuous variable.</p></li>
<li><p>In order to be able to combine output from stateTables() and stateTableContinuous() into one data.frame, they needed to have the same column names. As a result, output from stateTableContinuous() is a little awkward to interpret. Specifically:</p></li>
<li><p>ownershipsInDomain, ownershipsInPopulation and acresInPopulation mean just what they sound like. ownershipsInDomain will always equal ownershipsInPopulation.</p></li>
<li><p>But, acresInDomain refers to the estimate of total, not for acres, but for the continuous variable of interest (say, age). And meanAcresInDomain refers to the estimated mean value of that variable per ownership. Per acre mean should be incorporated at some point.</p></li>
<li><p>Proportions are obviously not meaningful, and are all set to 1. Their variances are set to &ldquo;NA&rdquo;.</p></li>
</ul>

<h3>Anyway, first build the stratum level tables:</h3>

<pre><code class="r">t23State_11 = stateTables(385:387, questAll_11, ns_11, factor(rep(&quot;population&quot;, 
    nrow(questAll_11))))
</code></pre>

<pre><code>## [1] &quot;estimated total time: 7 sec.&quot;
</code></pre>

<pre><code class="r">t433State_11 = stateTables(c(388:ncol(questAll_11), 379:380, 382:384), questAll_11, 
    ns_11, questAll_11$population__family)
</code></pre>

<pre><code>## [1] &quot;estimated total time: 183 sec.&quot;
</code></pre>

<pre><code class="r">tAgeState_11 = stateTableContinuous(c(14, 273:274), questAll_11, ns_11, questAll_11$population__family)
t433State_11 = rbind(t433State_11, tAgeState_11)
</code></pre>

<h3>Then, to make the reginal and national tables:</h3>

<p>Use regionTables(), which simply sums rows for totals and variances and combines rows appropriately for means, proportions and their variances. The function regionTables() only requires the stateTables() output:</p>

<pre><code class="r">t23Region_11 = regionTables(t23State_11[t23State_11$stateCd != 2, ])
</code></pre>

<pre><code>## Loading required package: plyr
</code></pre>

<pre><code class="r">t433Region_11 = regionTables(t433State_11[t433State_11$stateCd != 2, ])
</code></pre>

<h3>Where to send them:</h3>

<p>Finally, you can write these to the output folder in the dropbox, after changing &ldquo;outputwd&rdquo; to the appropriate directory for your computer:</p>

<pre><code class="r">outputwd = &quot;C:/Users/FFRC_BRENT/Dropbox/NWOS/brents nwos stuff/output data/&quot;
write.csv(t23State_11, paste(outputwd, &quot;nwos tables/nwos tables 2-3 by state&quot;, 
    substr(Sys.time(), 1, 10), &quot;.csv&quot;, sep = &quot;&quot;), row.names = F)
write.csv(t23Region_11, paste(outputwd, &quot;nwos tables/nwos tables 2-3 by region&quot;, 
    substr(Sys.time(), 1, 10), &quot;.csv&quot;, sep = &quot;&quot;), row.names = F)
write.csv(t433State_11, paste(outputwd, &quot;nwos tables/nwos tables 4-33 by state&quot;, 
    substr(Sys.time(), 1, 10), &quot;.csv&quot;, sep = &quot;&quot;), row.names = F)
write.csv(t433Region_11, paste(outputwd, &quot;nwos tables/nwos tables 4-33 by region&quot;, 
    substr(Sys.time(), 1, 10), &quot;.csv&quot;, sep = &quot;&quot;), row.names = F)
</code></pre>

</body>

</html>

